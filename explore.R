library('rgdal')
library('Hmisc')
library('foreign')
library('readxl')
library('raster')
library('plyr')
library('stringr')

root <- getwd()

#===============================================================================
# Habitattypen
#===============================================================================

setwd(root)

habitattypen <- readOGR('data/Habitattypenkaart_Overijssel', stringsAsFactors=F)

# Lijst van Natura2000-gebieden in Overijssel:
(N2 <- (N2<-habitattypen@data[c('N2K_NUMMER','N2K_GEBIED')])[!duplicated(N2),])

simplify_habitat <- function(
    ht, 
    colselect = c(
        'OBJECTID', 'polygon', 'N2K_NUMMER', 'N2K_GEBIED', 'PERC_TOT',
        'LEG_EENV', 'LEG_COMPL', 'deelgebied', 'HABTYPE', 'VEGTYPE', 'PERC',
        'OPP')) {
    ht$polygon <- rownames(ht)
    c1 <- c('OBJECTID', 'N2K_NUMMER', 'N2K_GEBIED', 'DATUM', 'METHODE', 'BRON',
        'VEG_TYPO', 'PERC_TOT', 'OPMERKING', 'OPMERKING2', 'LEG_EENV', 
        'LEG_COMPL', 'ID_BRON',  'STATUS', 'VERSIE', 'INCONSTIST', 'SHAPE_AREA', 
        'SHAPE_LEN', 'polygon')
    c2 <- names(ht)[!(names(ht) %in% c1)]
    d1 <- ht[c1]     # the columns referring to gebied
    d2 <- ht[c(c2)]  # the columsn referring to deelgebieden
    get_variable   <- function(colheader) str_extract(colheader, '(\\b[A-Z]+)')
    get_deelgebied <- function(colheader) as.integer(str_extract(colheader, '(\\d+\\b)'))
    f <- function(cols) {
        # Remove numeric suffix from column headers and indicate deelgebied in an
        # extra collumns in stead:
        d <- d2[cols]
        deelgebied <- get_deelgebied(names(d)[-1])[1]
        names(d) <- mapply(get_variable, names(d))
        cbind(d1, deelgebied=deelgebied, d)
        }
    dd <- Map(f, split(c2, mapply(get_deelgebied, c2)))
    deelgebied <- do.call(rbind, dd)
    # We can now remove unused data fields:
    n0 <- nrow(deelgebied)
    deelgebied <- deelgebied[!is.na(deelgebied$HABTYPE),]
    nrow(deelgebied)/n0 # What a waste!
    deelgebied  <- deelgebied[order(deelgebied$OBJECTID, deelgebied$deelgebied),]
    rownames(deelgebied) <- NULL
    deelgebied[colselect]
}

habitat <- simplify_habitat(habitattypen@data)
N2K <- ddply(habitat, .(N2K_NUMMER, N2K_GEBIED), summarize, 
             deelgebieden=length(deelgebied), polygons=length(polygon), 
             oppervlakte=sum(OPP))
N2K$rapportage <- !N2K$N2K_GEBIED %in% c(
                          'Aamsveen', 
                          'Achter de Voort, Agelerbroek & Voltherbroek',
                          'Boetelerveld',
                          'Engbertdijksvenen',
                          'Landgoederen Oldenzaal',
                          'Lemselermaten',
                          'Witte Veen')
N2K[order(N2K$polygons), ]

#===============================================================================
# Lonnekermeer
#===============================================================================

#BUG: -9999

#===============================================================================
# Bergvennen & Brecklenkampse Veld
#===============================================================================

N2K_gebied <- 'Bergvennen & Brecklenkampse Veld'
setwd('data/Bergvennen_Brecklenkampse_Veld')

hab <- habitattypen[habitattypen$N2K_GEBIED == N2K_gebied, ]

layers <- (layers <- ogrListLayers('.'))[layers != 'vlakken']
spds <- Map(function(layer) readOGR('.', layer, stringsAsFactors=F), layers)
vars <- c('GLG', 'GVG', 'pH', 'Trofie')

merge_spd <- function(var.x, spd.x, var.y, spd.y) {
    spd.x@data[var.x] <- spd.x@data$EIV
    spd.x@data[var.y] <- spd.y@data$EIV
    spd.x
    }

spd <- merge_spd(vars[[1]], spds[[1]], vars[[2]], spds[[2]])
spd$EIV <- NULL
for (i in seq(2, length(vars)))
    spd <- merge_spd(vars[[1]], spd, vars[[i]], spds[[i]])
    

projection(i) <- projection(h)
intersection <- intersect(h, i)
red50  <- do.call(rgb, as.list(c(col2rgb('red'),  alpha=125, max=255)))
blue50 <- do.call(rgb, as.list(c(col2rgb('blue'), alpha=125, max=255)))
plot(h, axes=T, col=red50)
plot(i, col=blue50, add=T)
plot(intersection, add=T, col='red')

#===============================================================================
# Opnamen
#===============================================================================

setwd('zip/TurbovegSlBackup_Floranld_2013/')
Floranld_2013 <- list(species =read.dbf('species.dbf'),
                      ecodbase=read.dbf('ecodbase.dbf'))
setwd(root)

setwd('data/Buurserzand_Haaksbergerveen/')

opname <- list(abundance   =read.dbf('Turboveg_Haaksbergerveen/tvabund.dbf'),
               habitat_type=read.dbf('Turboveg_Haaksbergerveen/tvhabita.dbf'),
               remarks     =read.dbf('Turboveg_Haaksbergerveen/remarks.dbf'),
               admin       =read.dbf('Turboveg_Haaksbergerveen/TvAdmin.dbf'))
# This file has been generated by Turboveg 2 with Floranld_2013 as species list 
# and the above Turboveg database ('opname'):
iteratio_input <- read.csv('haaksbergerveen_iteratio_input.csv', sep='\t')

#===============================================================================
# Vegetatiekartering
#===============================================================================

vlakken <- readOGR('vlakken.shp') # kartering, geographic and meta-data
kartering <- mdb.get('0820_Haaksbergerveen.mdb') # kartering, vegetation types

# vlakken contains the polygons, kartering$Element the vegetations types
# (SbbType). There is (almost) a one-to-one relationship between
# vlakken@data$Elmid and kartering$Element$ElmID. However, some ElmID's in
# kartering$Element are duplicated:
elmid = kartering$Element$ElmID
dups = elmid[duplicated(elmid)]
dups = dups[order(dups)]
duplicated_elements = kartering$Element[elmid %in% dups,]
duplicated_elements[order(duplicated_elements$ElmID),]
# The duplications have ElemID 1 to 9, contain no data in many columns and have
# 'l' as Locatietype in stead of 'v'
kartering$Element[kartering$Element$Locatietype=='l',]

#===============================================================================
# Indicatiewaarden voor abiotische randvoorwaarden
#===============================================================================

# The shapefiles below have been generated by Iteratio with input:
# - Formattype: Digitale stanaard
# - Vegetatietabel: haaksbergerveen_iteratio_input.csv
# - Landschapstype: Hogere zandgronden
# - Shapefile (vlakken): vlakken.shp
# - MS Acces-database: 0820_Haaksbergerveen.mdb
# - Aantal iteraties: 100
layers <- (layers <- ogrListLayers('.'))[layers != 'vlakken']
indicatiewaarden <- Map(function(layer) readOGR('.', layer), layers)

# indicatiewaarden bevat voor het Natura2000-gebied per vegetatietype de
# "abiotische randvoorwaarden" geschat op basis van de waargenomen
# plantensoorten en de andere invoer van Iteratio. Elke layer in
# indicatiewaarden correspondeert met een abiotische randvoorwaarde en binnen
# elke layer correspondeert een polygon met een vegetatietype en een
# indicatiewaarde van de abiotische randvoorwaarde. (De indicatiewaarde lijkt
# echter voor elk vegetatietype hetzelfde onafhanklijk van het polygon.)

#===============================================================================
# 
#===============================================================================

# https://gis.stackexchange.com/questions/140504/extracting-intersection-areas-in-r
h <- habitattypen[habitattypen$N2K_GEBIED == 'Buurserzand & Haaksbergerveen',]
#h <- as(h, 'SpatialPolygons')
i <- indicatiewaarden[['Haaksbergerveen - pH - H20']]
projection(i) <- projection(h)
intersection <- intersect(h, i)
red50  <- do.call(rgb, as.list(c(col2rgb('red'),  alpha=125, max=255)))
blue50 <- do.call(rgb, as.list(c(col2rgb('blue'), alpha=125, max=255)))
plot(h, axes=T, col=red50)
plot(i, col=blue50, add=T)
plot(intersection, add=T, col='red')

#===============================================================================
# Bergvennen & Brecklenkampse Veld
#===============================================================================

N2K_gebied <- 'Bergvennen & Brecklenkampse Veld'
setwd('data/Bergvennen_Brecklenkampse_Veld')

hab <- habitattypen[habitattypen$N2K_GEBIED == N2K_gebied,]
hab$polygon <- rownames(hab@data)
hab_ <- simplify_habitat(hab@data)

layers <- (layers <- ogrListLayers('.'))[layers != 'vlakken']
spds <- Map(function(layer) readOGR('.', layer, stringsAsFactors=F), layers)
vars <- c('GLG', 'GVG', 'pH', 'Trofie')
eiv <- merge_spd(vars, spds)

# https://gis.stackexchange.com/a/140536/182236:
#projection(eiv) <- projection(hab)
intersection <- intersect(hab, eiv)
intersection$opp <- area(intersection)

red50  <- do.call(rgb, as.list(c(col2rgb('red'),  alpha=125, max=255)))
blue50 <- do.call(rgb, as.list(c(col2rgb('blue'), alpha=125, max=255)))

# Habitats met meerdere deelgebieden:
d=ddply(hab_, .(polygon), summarize, deelgebieden=max(deelgebied))
d=d[d$deelgebieden>1,]
hab_[hab_$polygon %in% d$polygon,]

colselect_is <- c('ELMID', 'polygon', 'opp', 'GLG', 'GVG', 'pH', 'Trofie')

# A habitat with NA's in the intersection:
plgn <- '39255'
(i <- intersection[colselect_is][intersection$polygon==plgn,]@data)
eiv[eiv$ELMID %in% i$ELMID, ]@data
hab[colselect_ht0][hab$polygon==plgn,]@data
sum(eiv$PERC_TOT[is.na(eiv$pH)]) # 0
#NOTE: Het ziet er naar uit dat NA's alleen voorkomen als PERC_TOT nul is.

plot(hab, axes=T, border=red50, xlim=c(264900, 265100), ylim=c(496000, 496000)) 
plot(eiv, add=T, border=blue50)
for (p in d$polygon) {
    cat(paste('Plotting polygon', p, '\n'))
    plot(hab[hab@data$polygon == p,], add=T, col=red50, border=NULL)
    invisible(readline(prompt="Press [enter] to continue"))
}

# This seems an interesting habitat:
p <- 39321
#p <- 39668
plot(hab, axes=T, border=red50, xlim=c(264900, 265100), ylim=c(496000, 496000)) 
plot(eiv, add=T, border=blue50)
plot(hab[hab@data$polygon == p,], add=T, col=red50, border=NULL)
plot(intersection[intersection@data$polygon == p, ], add=T, col=blue50, border=NULL)
hab[colselect_ht0][hab$polygon == p,]@data
hab_[hab_$polygon == p,]
intersection[colselect_is][intersection$polygon == p,]@data

# Indicatiewaarden, gemiddelde gewogen naar oppervlakte:
eiv_pg <- ddply(intersection@data, .(polygon), summarize, 
                GLG=weighted.mean(GLG, opp, na.rm=T),
                GVG=weighted.mean(GVG, opp, na.rm=T),
                pH=weighted.mean(pH, opp, na.rm=T),
                Trofie=weighted.mean(Trofie, opp, na.rm=T))
#NOTE: We take the arithmetic mean of pH, which is at best an arbitrary choice.
# Geometric mean would more logical. However, the result is probably only
# slightly different. I don't know what 'Trofie' is, so I don't know
# which mean is appropriate there.
hab_ <- merge(hab_, eiv_pg, by='polygon', all.x=T)
head(hab_)
# Indicatiewaarden per habitattype:
result <- ddply(hab_, .(N2K_GEBIED, HABTYPE), summarize,
                GLG=weighted.mean(GLG, OPP, na.rm=T),
                GVG=weighted.mean(GVG, OPP, na.rm=T),
                pH=weighted.mean(pH, OPP, na.rm=T),
                Trofie=weighted.mean(Trofie, OPP, na.rm=T))
result

#TODO:
#1. Voeg jaar toe aan result
#2. Bepaal in welk bereik een waarde ligt.
